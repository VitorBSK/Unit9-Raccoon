//! ===========================================================================
//! Unit09 – Fork State (Unit09 Variants)
//! Path: contracts/unit09-program/programs/unit09_program/src/state/fork.rs
//!
//! A `Fork` represents a distinct variant of Unit09:
//! - different configuration
//! - different module composition
//! - different “personality” or evolution path
//!
//! Forks are intended to be long-lived entities that:
//! - reference a parent (another fork or a root identity)
//! - are owned by an authority
//! - can be activated / deactivated
//! - carry their own metadata and tags
//!
//! This file defines:
//! - `Fork` account structure
//! - size constants for rent-exempt allocation
//! - helpers for ownership checks, activation, lineage, and validation
//! ===========================================================================

use anchor_lang::prelude::*;

use crate::constants::*;
use crate::errors::Unit09Error;

/// Fork account tracked by Unit09.
///
/// Conceptually:
/// - `Fork` is a specific “branch” of Unit09’s behavior and configuration
/// - It may reference a subset of modules, a different orchestration strategy,
///   or even different off-chain worker behavior
#[account]
pub struct Fork {
    /// Arbitrary key chosen to identify this fork at PDA derivation time.
    ///
    /// This can be derived from:
    /// - a hash of a fork configuration
    /// - a random key generated by the owner
    /// - an off-chain identifier
    pub fork_key: Pubkey,

    /// Parent reference in the fork tree.
    ///
    /// This may be:
    /// - another `Fork` PDA
    /// - a well-known root identity for the initial Unit09 instance
    pub parent: Pubkey,

    /// Owner authority of this fork.
    ///
    /// Only this key is allowed to:
    /// - update fork metadata
    /// - toggle active/inactive state
    pub owner: Pubkey,

    /// Human-readable label for this fork.
    ///
    /// Example: "unit09-lab-alpha", "production-v1", "canary-eu"
    pub label: String,

    /// Off-chain metadata URI describing this fork’s configuration.
    ///
    /// Example: a JSON manifest that includes:
    /// - selected modules
    /// - parameters for off-chain workers
    /// - narrative / personality details
    pub metadata_uri: String,

    /// Tags for search and discovery.
    ///
    /// Example: "alpha,experiment,high-risk"
    pub tags: String,

    /// Whether this fork is currently active.
    ///
    /// Inactive forks should not be used in new flows by default.
    pub is_active: bool,

    /// Whether this fork is considered “root-level” or derived.
    ///
    /// This field is purely informational and is not strictly required
    /// for correctness; off-chain tools may use it to render fork trees.
    pub is_root: bool,

    /// Depth of this fork in the tree.
    ///
    /// Root forks typically have depth 0 or 1. Derived forks increment
    /// depth from their parents.
    pub depth: u16,

    /// Total number of times this fork has been used in tracked operations.
    ///
    /// For example:
    /// - being selected for a run
    /// - being referenced in a deployment
    pub usage_count: u64,

    /// Last time this fork was used in a tracked way.
    pub last_used_at: i64,

    /// Unix timestamp when this fork was created.
    pub created_at: i64,

    /// Unix timestamp when this fork was last updated.
    pub updated_at: i64,

    /// Schema version for this fork layout.
    pub schema_version: u8,

    /// Bump used for PDA derivation.
    pub bump: u8,

    /// Reserved bytes for future upgrades.
    pub reserved: [u8; 62],
}

impl Fork {
    /// Discriminator length used by Anchor.
    pub const DISCRIMINATOR_LEN: usize = 8;

    /// Maximum length in bytes (UTF-8) for the `label` field.
    pub const MAX_LABEL_LEN: usize = MAX_NAME_LEN;

    /// Maximum length in bytes (UTF-8) for the `metadata_uri` field.
    pub const MAX_METADATA_URI_LEN: usize = MAX_METADATA_URI_LEN;

    /// Maximum length in bytes (UTF-8) for the `tags` field.
    pub const MAX_TAGS_LEN: usize = MAX_TAGS_LEN;

    /// Total serialized length of the `Fork` account.
    ///
    /// Strings are encoded as:
    ///     4-byte length prefix + bytes
    pub const LEN: usize = Self::DISCRIMINATOR_LEN
        + 32 // fork_key: Pubkey
        + 32 // parent: Pubkey
        + 32 // owner: Pubkey
        + 4 + Self::MAX_LABEL_LEN // label: String
        + 4 + Self::MAX_METADATA_URI_LEN // metadata_uri: String
        + 4 + Self::MAX_TAGS_LEN // tags: String
        + 1 // is_active: bool
        + 1 // is_root: bool
        + 2 // depth: u16
        + 8 // usage_count: u64
        + 8 // last_used_at: i64
        + 8 // created_at: i64
        + 8 // updated_at: i64
        + 1 // schema_version: u8
        + 1 // bump: u8
        + 62; // reserved: [u8; 62]

    // -----------------------------------------------------------------------
    // Initialization
    // -----------------------------------------------------------------------

    /// Initialize a new fork instance.
    ///
    /// This is typically called from the `create_fork` instruction.
    pub fn init(
        &mut self,
        fork_key: Pubkey,
        parent: Pubkey,
        owner: Pubkey,
        label: String,
        metadata_uri: String,
        tags: String,
        is_root: bool,
        depth: u16,
        bump: u8,
        clock: &Clock,
    ) -> Result<()> {
        Self::validate_label(&label)?;
        Self::validate_metadata_uri(&metadata_uri)?;
        Self::validate_tags(&tags)?;
        Self::validate_depth(depth)?;

        self.fork_key = fork_key;
        self.parent = parent;
        self.owner = owner;
        self.label = label;
        self.metadata_uri = metadata_uri;
        self.tags = tags;
        self.is_active = true;
        self.is_root = is_root;
        self.depth = depth;
        self.usage_count = 0;
        self.last_used_at = 0;
        self.created_at = clock.unix_timestamp;
        self.updated_at = clock.unix_timestamp;
        self.schema_version = CURRENT_SCHEMA_VERSION;
        self.bump = bump;
        self.reserved = [0u8; 62];

        Ok(())
    }

    // -----------------------------------------------------------------------
    // Metadata / State Updates
    // -----------------------------------------------------------------------

    /// Apply updates to this fork.
    ///
    /// Used by `update_fork_state` or similar instructions to mutate fields
    /// selectively without reconstructing the whole struct.
    pub fn apply_update(
        &mut self,
        maybe_label: Option<String>,
        maybe_metadata_uri: Option<String>,
        maybe_tags: Option<String>,
        maybe_is_active: Option<bool>,
        clock: &Clock,
    ) -> Result<()> {
        if let Some(label) = maybe_label {
            Self::validate_label(&label)?;
            self.label = label;
        }

        if let Some(metadata_uri) = maybe_metadata_uri {
            Self::validate_metadata_uri(&metadata_uri)?;
            self.metadata_uri = metadata_uri;
        }

        if let Some(tags) = maybe_tags {
            Self::validate_tags(&tags)?;
            self.tags = tags;
        }

        if let Some(is_active) = maybe_is_active {
            self.is_active = is_active;
        }

        self.updated_at = clock.unix_timestamp;
        Ok(())
    }

    /// Optionally update the parent and depth for this fork in a controlled
    /// way, if your protocol allows reparenting.
    pub fn reparent(
        &mut self,
        new_parent: Pubkey,
        new_depth: u16,
        clock: &Clock,
    ) -> Result<()> {
        Self::validate_depth(new_depth)?;
        self.parent = new_parent;
        self.depth = new_depth;
        self.updated_at = clock.unix_timestamp;
        Ok(())
    }

    // -----------------------------------------------------------------------
    // Authority and Activation Guards
    // -----------------------------------------------------------------------

    /// Ensure that the signer is the owner of this fork.
    pub fn assert_owner(&self, signer: &Signer) -> Result<()> {
        if signer.key() != self.owner {
            return err!(Unit09Error::InvalidForkOwner);
        }
        Ok(())
    }

    /// Ensure that the fork is currently active.
    pub fn assert_active(&self) -> Result<()> {
        if !self.is_active {
            return err!(Unit09Error::ForkInactive);
        }
        Ok(())
    }

    // -----------------------------------------------------------------------
    // Usage Tracking
    // -----------------------------------------------------------------------

    /// Record a usage event for this fork.
    ///
    /// This can be called when:
    /// - the fork is selected by workers
    /// - a composed deployment is created referencing this fork
    pub fn record_usage(&mut self, clock: &Clock) -> Result<()> {
        self.usage_count = self
            .usage_count
            .checked_add(1)
            .ok_or(Unit09Error::CounterOverflow)?;
        self.last_used_at = clock.unix_timestamp;
        Ok(())
    }

    // -----------------------------------------------------------------------
    // Validation Helpers
    // -----------------------------------------------------------------------

    /// Validate label string.
    fn validate_label(label: &str) -> Result<()> {
        if label.is_empty() {
            return err!(Unit09Error::StringEmpty);
        }
        if label.len() > Self::MAX_LABEL_LEN {
            return err!(Unit09Error::StringTooLong);
        }
        Ok(())
    }

    /// Validate metadata URI for this fork.
    fn validate_metadata_uri(uri: &str) -> Result<()> {
        if uri.is_empty() {
            return err!(Unit09Error::StringEmpty);
        }
        if uri.len() > Self::MAX_METADATA_URI_LEN {
            return err!(Unit09Error::StringTooLong);
        }

        let has_known_prefix = uri.starts_with("http://")
            || uri.starts_with("https://")
            || uri.starts_with("ipfs://")
            || uri.starts_with("ar://");

        if !has_known_prefix {
            return err!(Unit09Error::MetadataInvalid);
        }

        Ok(())
    }

    /// Validate tags string.
    fn validate_tags(tags: &str) -> Result<()> {
        if tags.len() > Self::MAX_TAGS_LEN {
            return err!(Unit09Error::StringTooLong);
        }
        Ok(())
    }

    /// Validate depth value.
    fn validate_depth(depth: u16) -> Result<()> {
        // Depth 0 and above are allowed; you can add an upper bound if needed.
        if depth > 10_000 {
            return err!(Unit09Error::ValueOutOfRange);
        }
        Ok(())
    }
}
